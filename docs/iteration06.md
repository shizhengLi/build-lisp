# 迭代6：内置数学运算符

## 概述
在本迭代中，我们完善和扩展了迭代5中介绍的数学运算符系统。我们添加了全面的错误处理、一元运算支持，并确保了数学计算中边缘情况的稳健行为。

## 知识点

### 1. 数学运算符理论
- **二元运算**：具有两个或更多操作数的标准算术运算
- **一元运算**：支持取负（一元减号）
- **操作数验证**：类型检查和参数计数验证
- **错误条件**：除零、模零、无效运算符

### 2. 错误处理策略
- **早期验证**：在执行操作前检查参数
- **内存安全**：即使发生错误也能正确清理资源
- **错误传播**：确保错误在求值栈中向上传递
- **描述性消息**：针对不同失败条件的清晰错误消息

### 3. 求值中的内存管理
- **资源所有权**：明确理解哪个函数拥有哪块内存
- **错误时清理**：确保操作失败时没有内存泄漏
- **临时值管理**：正确处理中间计算结果

## 实现细节

### 增强的内置运算符函数
```c
Lval *builtin_op(Lenv *e, Lval *a, char *op) {
    // 检查运算符是否有效
    if (strcmp(op, "+") != 0 && strcmp(op, "-") != 0 && 
        strcmp(op, "*") != 0 && strcmp(op, "/") != 0 && strcmp(op, "%") != 0) {
        lval_free(a);
        return lval_err("无效运算符！");
    }
    
    // 确保所有参数都是数字
    for (int i = 0; i < a->sexpr.count; i++) {
        if (a->sexpr.cell[i]->type != LVAL_NUM) {
            lval_free(a);
            return lval_err("不能对非数字进行运算！");
        }
    }
    
    Lval *x = lval_pop(a, 0);
    
    // 处理一元减号
    if ((strcmp(op, "-") == 0) && a->sexpr.count == 0) {
        x->num = -x->num;
    }
    
    // 当还有剩余元素时
    while (a->sexpr.count > 0) {
        Lval *y = lval_pop(a, 0);
        
        if (strcmp(op, "+") == 0) { x->num += y->num; }
        if (strcmp(op, "-") == 0) { x->num -= y->num; }
        if (strcmp(op, "*") == 0) { x->num *= y->num; }
        if (strcmp(op, "/") == 0) { 
            if (y->num == 0) {
                lval_free(x);
                lval_free(y);
                x = lval_err("除零错误！");
                break;
            }
            x->num /= y->num; 
        }
        if (strcmp(op, "%") == 0) { 
            if (y->num == 0) {
                lval_free(x);
                lval_free(y);
                x = lval_err("模零错误！");
                break;
            }
            x->num %= y->num; 
        }
        
        lval_free(y);
    }
    
    lval_free(a);
    return x;
}
```

### 支持的运算

#### 加法 (+)
- **语法**：`(+ 数字1 数字2 ...)`
- **行为**：对所有数字求和
- **示例**：
  - `(+ 1 2 3)` → `6`
  - `(+ 10)` → `10`
  - `(+)` → 错误（一元上下文至少需要一个参数）

#### 减法 (-)
- **语法**：`(- 数字1 数字2 ...)` 或 `(- 数字)`
- **行为**：从第一个数字中减去所有后续数字，或对单个数字取负
- **示例**：
  - `(- 10 3 2)` → `5`
  - `(- 5)` → `-5`（一元取负）

#### 乘法 (*)
- **语法**：`(* 数字1 数字2 ...)`
- **行为**：将所有数字相乘
- **示例**：
  - `(* 2 3 4)` → `24`
  - `(* 5)` → `5`

#### 除法 (/)
- **语法**：`(/ 数字1 数字2 ...)`
- **行为**：用第一个数字除以所有后续数字
- **错误**：除零返回错误
- **示例**：
  - `(/ 100 5 2)` → `10`
  - `(/ 10 0)` → 错误："除零错误！"

#### 取模 (%)
- **语法**：`(% 数字1 数字2)`
- **行为**：返回除法的余数（当前仅支持二元）
- **错误**：模零返回错误
- **示例**：
  - `(% 17 5)` → `2`
  - `(% 10 0)` → 错误："模零错误！"

## 挑战与解决方案

### 1. 一元运算符支持
**问题**：减法运算符需要支持二元减法和一元取负。

**解决方案**：添加特殊逻辑来检测`-`何时只与一个参数一起使用，并将其作为取负处理：
```c
if ((strcmp(op, "-") == 0) && a->sexpr.count == 0) {
    x->num = -x->num;
}
```

### 2. 除零处理
**问题**：除零在数学上是未定义的，可能导致程序崩溃。

**解决方案**：在除法运算前添加显式检查：
```c
if (y->num == 0) {
    lval_free(x);
    lval_free(y);
    x = lval_err("除零错误！");
    break;
}
```

### 3. 错误情况下的内存泄漏
**问题**：当求值过程中发生错误时，需要正确清理中间值。

**解决方案**：确保在返回错误之前正确清理所有分配的内存：
```c
lval_free(x);
lval_free(y);
x = lval_err("除零错误！");
```

### 4. 类型安全
**问题**：数学运算应该只对数字有效，但求值系统可能传递其他类型。

**解决方案**：添加全面的类型检查：
```c
for (int i = 0; i < a->sexpr.count; i++) {
    if (a->sexpr.cell[i]->type != LVAL_NUM) {
        lval_free(a);
        return lval_err("不能对非数字进行运算！");
    }
}
```

### 5. 运算符验证
**问题**：系统需要区分有效的数学运算符和无效符号。

**解决方案**：添加显式运算符验证：
```c
if (strcmp(op, "+") != 0 && strcmp(op, "-") != 0 && 
    strcmp(op, "*") != 0 && strcmp(op, "/") != 0 && strcmp(op, "%") != 0) {
    lval_free(a);
    return lval_err("无效运算符！");
}
```

## 测试覆盖
扩展测试以涵盖：
- 具有多个参数的所有数学运算
- 一元取负功能
- 除零错误处理
- 模零错误处理
- 非数字参数的类型错误处理
- 无效运算符错误处理
- 嵌套数学表达式
- 单个参数的边缘情况

## 使用示例
数学运算符现在可靠地工作：

```lisp
lispy> (+ 1 2 3 4 5)
15

lispy> (- 100 50 25)
25

lispy> (- 10)
-10

lispy> (* 2 3 4)
24

lispy> (/ 100 5 2)
10

lispy> (% 17 5)
2

lispy> (/ 10 0)
Error: 除零错误！

lispy> (+ 1 "two")
Error: 不能对非数字进行运算！

lispy> (invalid 1 2)
Error: 无效运算符！
```

## 性能考虑
- **内存效率**：正确清理防止运算过程中的内存泄漏
- **早期验证**：参数无效时快速失败
- **迭代处理**：顺序处理参数以最小化内存使用

## 当前限制
- 取模运算当前仅支持两个参数
- 不支持浮点数（仅整数）
- 没有内置数学函数（sin、cos、sqrt等）
- 仅限于基本算术运算

## 下一步
随着稳健的数学运算符的实现，下一个迭代将专注于添加列表操作函数（head、tail、list、cons、join），以扩展解释器超越数值计算的能力。

## 关键修改文件
- `src/eval.c`：增强的数学运算符实现
- `test/test_eval.c`：扩展的数学运算测试覆盖
- `docs/iteration6.md`：本文档文件