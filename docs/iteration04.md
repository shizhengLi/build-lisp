# 迭代4: 支持S-表达式(列表)

## 目标
Lval支持列表（S-expr），用指针数组模拟cons cells。

## 实现过程

### TDD流程

#### 1. Red - 编写失败的测试
编写了五个测试：
- `test_lval_sexpr()`: 创建空列表，添加元素，验证count和cell
- `test_lval_pop()`: 测试从列表中弹出元素
- `test_lval_take()`: 测试从列表中取出元素并释放原列表
- `test_sexpr_print()`: 测试列表的字符串表示
- `test_nested_sexpr()`: 测试嵌套列表

#### 2. Green - 实现最小代码
实现了列表操作函数：
- `lval_add()`: 向列表添加元素
- `lval_pop()`: 从列表中弹出元素（不释放列表）
- `lval_take()`: 从列表中取出元素（释放原列表）
- `lval_to_string()`: 支持列表的字符串表示

#### 3. Refactor - 重构优化
- 改善了字符串表示的内存管理
- 优化了列表操作的性能
- 添加了嵌套列表支持

## 知识点总结

### 1. 动态数组管理
- `realloc()`: 动态调整数组大小
- `memmove()`: 内存块移动，用于删除元素
- 指针数组：存储Lval指针的数组

### 2. 列表操作语义
- `lval_add()`: 修改原列表，返回列表本身
- `lval_pop()`: 不释放原列表，返回被弹出元素
- `lval_take()`: 释放原列表，返回被取出元素

### 3. 递归数据结构
- 嵌套列表：列表可以包含其他列表
- 递归释放：需要递归释放所有子节点
- 递归打印：深度优先遍历所有子节点

## 技术细节

### 列表内存布局
```c
struct {
    struct Lval **cell;  // 指向Lval指针数组的指针
    int count;           // 当前元素数量
} sexpr;
```

### 添加元素操作
```c
v->sexpr.count++;
v->sexpr.cell = realloc(v->sexpr.cell, sizeof(Lval*) * v->sexpr.count);
v->sexpr.cell[v->sexpr.count - 1] = x;
```

### 弹出元素操作
```c
Lval *x = v->sexpr.cell[i];
memmove(&v->sexpr.cell[i], &v->sexpr.cell[i + 1], 
        sizeof(Lval*) * (v->sexpr.count - i - 1));
v->sexpr.count--;
```

## 踩坑记录

### 1. 内存管理复杂性
**问题**: 列表操作涉及多个内存分配和释放
**解决**: 仔细区分pop和take的语义，明确内存所有权

### 2. 字符串缓冲区溢出
**问题**: 嵌套列表的字符串表示可能很长
**解决**: 增加缓冲区大小到1024字节

### 3. 递归释放的正确性
**问题**: 需要确保所有子节点都被正确释放
**解决**: 在`lval_free()`中添加递归释放逻辑

### 4. 索引边界检查
**问题**: pop和take操作需要检查索引范围
**解决**: 虽然当前没有添加边界检查，但实际使用时需要考虑

## 性能分析

### 时间复杂度
- `lval_add()`: O(1) 平均时间（摊销）
- `lval_pop()`: O(n) 最坏情况（需要移动元素）
- `lval_take()`: O(n) 最坏情况
- `lval_to_string()`: O(n) (n为所有节点的总数)

### 空间复杂度
- 列表本身：O(n) (n为元素数量)
- 字符串表示：O(n) (临时分配)

## 测试结果
- 单元测试: 5个测试全部通过
- 内存检查: Valgrind显示无内存泄漏
- 功能验证: 支持嵌套列表和正确打印

## 设计考虑

### 与传统Lisp的对比
- 传统Lisp使用cons cells (car/cdr)
- 本实现使用动态数组，更适合现代CPU缓存
- 随机访问更快，但插入/删除较慢

### 扩展性
- 当前实现支持基本的列表操作
- 可以扩展添加更多列表操作函数
- 为后续的求值和函数调用做好准备

## 下一步
实现基本求值功能，支持原子类型的求值。