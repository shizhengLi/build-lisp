# 迭代3: 定义Lisp值结构(Lval)

## 目标
用结构体表示Lisp对象（数字、符号、错误）。

## 实现过程

### TDD流程

#### 1. Red - 编写失败的测试
编写了四个测试：
- `test_lval_num()`: 创建数字Lval，验证值
- `test_lval_sym()`: 创建符号Lval，验证符号
- `test_lval_err()`: 创建错误Lval，验证消息
- `test_lval_print()`: 测试字符串转换功能

#### 2. Green - 实现最小代码
实现了Lval结构体和相关函数：
- `Lval`结构体：使用联合体存储不同类型的数据
- 创建函数：`lval_num()`, `lval_sym()`, `lval_err()`, `lval_sexpr()`
- 内存管理：`lval_free()`
- 字符串转换：`lval_to_string()`

#### 3. Refactor - 重构优化
- 改善了内存管理，特别是S-表达式的递归释放
- 添加了类型枚举定义
- 实现了完整的字符串表示

## 知识点总结

### 1. 联合体(Union)的使用
- 节省内存：同一时间只存储一种类型的数据
- 类型安全：通过type字段区分当前存储的数据类型
- 灵活性：支持多种数据类型的统一接口

### 2. 内存管理
- 动态内存分配：`malloc()`分配结构体内存
- 字符串复制：`strdup()`复制字符串内容
- 递归释放：S-表达式需要递归释放所有子节点

### 3. 数据结构设计
- 枚举类型：定义Lisp值的类型
- 嵌套结构：S-表达式包含其他Lval指针
- 类型标签：每个值都有明确的类型标识

## 技术细节

### Lval类型定义
```c
typedef enum {
    LVAL_NUM,   // 数字
    LVAL_SYM,   // 符号
    LVAL_SEXPR, // S表达式
    LVAL_ERR    // 错误
} LvalType;
```

### 联合体设计
```c
union {
    long num;              // 数字值
    char *sym;             // 符号字符串
    char *err;             // 错误消息
    struct {               // S表达式
        struct Lval **cell; // 子节点数组
        int count;         // 子节点数量
    } sexpr;
};
```

## 踩坑记录

### 1. 缺少头文件包含
**问题**: 编译时报错，缺少标准库头文件
**解决**: 在测试文件中添加`stdio.h`, `stdlib.h`, `string.h`

### 2. 内存泄漏风险
**问题**: S-表达式需要递归释放所有子节点
**解决**: 在`lval_free()`中添加递归释放逻辑

### 3. 字符串缓冲区安全
**问题**: `snprintf()`需要确保不会溢出缓冲区
**解决**: 使用固定大小缓冲区并正确截断字符串

### 4. 类型转换
**问题**: 需要将各种类型转换为字符串表示
**解决**: 使用`snprintf()`和`strncpy()`安全地格式化字符串

## 测试结果
- 单元测试: 4个测试全部通过
- 内存检查: Valgrind显示无内存泄漏
- 类型安全: 所有类型转换正确

## 性能考虑

### 内存使用
- 基本类型：一个结构体大小
- S-表达式：结构体 + 指针数组 + 各子节点
- 字符串：动态分配，避免固定大小限制

### 时间复杂度
- 创建：O(1)
- 释放：O(n) (n为S-表达式的子节点数)
- 字符串转换：O(1)

## 下一步
支持S-表达式(列表)，实现列表操作功能。