### 用 C 语言实现 Lisp 的行动计划：基于 TDD 的小步快跑策略

大家好！根据你的要求，我为你构思了一个详细的行动计划，用 C 语言从零实现一个简化的 Lisp 解释器（类似于 Scheme 或 Common Lisp 的子集）。这个计划以《Build Your Own Lisp》书籍为蓝本（因为它是最经典的 C 实现指南），但严格融入测试驱动开发 (TDD) 原则：**红-绿-重构**（先写失败的测试 Red，然后实现代码使测试通过 Green，最后重构代码）。我们采用“小步快跑”策略，将整个项目分解成 10-15 个小迭代，每个迭代聚焦一个最小可验证功能 (MVF)，目标是每个迭代结束时单元测试 100% 通过，然后逐步添加集成测试。

#### 总体原则
- **开发环境**：使用 GCC (C99 标准) 编译。推荐 VS Code 或 CLion 作为 IDE。引入 MPC (Mini Parser Combinators) 库用于解析（从书籍网站下载，或手动实现简单版本）。
- **测试框架**：使用 MinUnit（一个轻量级 C 单元测试框架，单头文件，易集成）。每个模块都有独立的测试文件（如 `test_lval.c`）。目标：单元测试覆盖率 100%（用 gcov 检查）。集成测试用简单脚本运行 REPL 并验证输出。
- **TDD 流程**：每个步骤：
  1. **Red**：写测试，编译运行，确保失败。
  2. **Green**：实现最小代码，使测试通过。
  3. **Refactor**：优化代码，确保测试仍通过。
- **版本控制**：用 Git，每迭代提交一次。分支名为 `feature/step-N`。
- **小步快跑**：每个迭代 1-2 天完成，聚焦一个功能。总时长估计 2-4 周。
- **最终目标**：一个支持基本 S-表达式、变量、函数、条件、递归和宏的 Lisp REPL。能运行如 `(defmacro when (cond body) (if cond (do body) nil))` 的代码。
- **风险管理**：内存泄漏用 Valgrind 检查。每个迭代末尾运行所有测试。

#### 详细行动计划
计划分为 12 个迭代，按顺序执行。前期聚焦基础数据结构和解析，中期求值和内置，后期高级特性如宏。每个迭代包括目标、TDD 任务、预期输出和检查点。

**迭代 1: 设置基本 REPL 框架（无 Lisp 功能）**
- **目标**：创建一个简单的命令行 REPL，能读取输入、回显输出。
- **TDD 任务**：
  - 写测试：`test_read_input()` – 输入 "hello"，期望输出 "hello"。
  - 实现：用 `readline` 或 `fgets` 读取输入，`printf` 输出。
  - 重构：添加错误处理（如空输入）。
- **单元测试**：1 个测试，100% 通过。
- **集成测试**：运行 `./lispy`，输入 "test"，验证回显。
- **检查点**：REPL 循环正常，无崩溃。

**迭代 2: 引入 MPC 解析器**
- **目标**：集成 MPC 库，能解析简单字符串（如数字、符号）。
- **TDD 任务**：
  - 写测试：`test_parse_number()` – 输入 "123"，期望 AST 节点为数字。
  - 实现：定义 MPC 规则（如 `number: /-?[0-9]+/ ;`），用 `mpc_parse`。
  - 重构：分离解析函数到 `parser.c`。
- **单元测试**：2 个（数字、符号），100% 通过。
- **集成测试**：REPL 中输入 "123"，打印解析结果。
- **检查点**：解析不抛异常。

**迭代 3: 定义 Lisp 值结构 (Lval)**
- **目标**：用结构体表示 Lisp 对象（数字、符号、错误）。
- **TDD 任务**：
  - 写测试：`test_lval_num()` – 创建 Lval 数字，验证值；`test_lval_err()` – 创建错误，验证消息。
  - 实现：定义 `enum ltype` 和 `struct lval`，添加创建函数如 `lval_num(long x)`。
  - 重构：添加打印函数 `lval_print`。
- **单元测试**：3 个（类型检查、创建、打印），100% 通过。
- **集成测试**：无（纯数据结构）。
- **检查点**：内存分配正常（用 Valgrind 检查）。

**迭代 4: 支持 S-表达式 (列表)**
- **目标**：Lval 支持列表（S-expr），用指针数组模拟 cons cells。
- **TDD 任务**：
  - 写测试：`test_lval_sexpr()` – 创建空列表，添加元素，验证 count 和 cell。
  - 实现：添加 `LVAL_SEXPR` 类型，`lval_add`、`lval_pop`、`lval_take` 函数。
  - 重构：优化内存管理。
- **单元测试**：4 个（添加、弹出、取值、深拷贝），100% 通过。
- **集成测试**：REPL 输入 "(1 2)"，解析成 Lval 列表。
- **检查点**：嵌套列表解析正确。

**迭代 5: 基本求值 (Eval) - 原子类型**
- **目标**：评估简单表达式，如数字或符号返回自身。
- **TDD 任务**：
  - 写测试：`test_eval_num()` – eval "123" 返回 123；`test_eval_sym()` – eval "+" 返回符号 "+"。
  - 实现：`lval_eval` 函数，switch 类型返回自身。
  - 重构：添加环境 stub（空结构体）。
- **单元测试**：2 个，100% 通过。
- **集成测试**：REPL eval "123" 输出 "123"。
- **检查点**：REPL 进入求值模式。

**迭代 6: 内置运算符（数学）**
- **目标**：支持 + - * / 等内置函数。
- **TDD 任务**：
  - 写测试：`test_builtin_add()` – eval "(+ 1 2)" 返回 3；处理错误如非数字。
  - 实现：`builtin_op` 函数，弹出参数，计算。
  - 重构：用宏定义运算符。
- **单元测试**：5 个（每个运算符 + 错误 case），100% 通过。
- **集成测试**：REPL 测试 "(+ 1 (* 2 3))" 输出 7。
- **检查点**：递归求值工作。

**迭代 7: 列表内置函数**
- **目标**：支持 head、tail、list、cons、join 等。
- **TDD 任务**：
  - 写测试：`test_builtin_head()` – "(head (list 1 2 3))" 返回 "(1)"。
  - 实现：类似 builtin_op，但处理列表。
  - 重构：统一 builtin 入口。
- **单元测试**：6 个（每个函数 + 边界），100% 通过。
- **集成测试**：组合测试如 "(join (list 1) (list 2))" 输出 "(1 2)"。
- **检查点**：列表操作无内存泄漏。

**迭代 8: 环境与变量**
- **目标**：支持变量定义和获取（如 def、put）。
- **TDD 任务**：
  - 写测试：`test_env_put_get()` – def {x} 10，get x 返回 10。
  - 实现：`lenv` 结构体，用哈希表（简单数组或 htable 库）存储。
  - 重构：支持全局/本地环境。
- **单元测试**：4 个（put、get、作用域、未定义错误），100% 通过。
- **集成测试**：REPL 测试 "(def {a} 5) (+ a 1)" 输出 6。
- **检查点**：环境隔离。

**迭代 9: 条件与控制流**
- **目标**：支持 if、=、> 等。
- **TDD 任务**：
  - 写测试：`test_builtin_if()` – "(if (= 1 1) {+ 1 2} {* 3 4})" 返回 3。
  - 实现：扩展 builtin，处理布尔逻辑。
  - 重构：添加 Q-expr（引号表达式）支持宏准备。
- **单元测试**：5 个（条件、比较），100% 通过。
- **集成测试**：嵌套 if 测试。
- **检查点**：布尔求值正确。

**迭代 10: 函数与 Lambda**
- **目标**：支持用户定义函数和匿名函数。
- **TDD 任务**：
  - 写测试：`test_lambda()` – "(\ {x} {+ x 1}) 5" 返回 6。
  - 实现：Lval 添加 LVAL_FUN 类型，闭包绑定环境。
  - 重构：递归调用支持。
- **单元测试**：4 个（定义、调用、闭包），100% 通过。
- **集成测试**：斐波那契递归测试。
- **检查点**：无栈溢出（简单 case）。

**迭代 11: 宏系统**
- **目标**：实现基本宏，能扩展语言（如 defmacro）。
- **TDD 任务**：
  - 写测试：`test_macro_expand()` – 定义 when 宏，"(when (= 1 1) {print "yes"})" 扩展为 if。
  - 实现：用 Q-expr 存储未求值代码，macro 是特殊函数，返回新表达式再 eval。
  - 重构：集成到 eval 中，区分宏调用。
- **单元测试**：3 个（定义、展开、执行），100% 通过。
- **集成测试**：自定义宏测试，如循环宏。
- **检查点**：宏不导致无限循环。

**迭代 12: 最终集成与优化**
- **目标**：完整 REPL，支持垃圾回收 (GC) 简单版，运行复杂代码。
- **TDD 任务**：
  - 写测试：全覆盖回归测试。
  - 实现：添加 mark-sweep GC。
  - 重构：性能优化，添加标准库（如 load 文件）。
- **单元测试**：所有先前测试 + 新 GC 测试，100% 通过。
- **集成测试**：运行示例 Lisp 程序，如计算器或简单 AI，验证输出。
- **检查点**：Valgrind 无泄漏，REPL 稳定。

#### 后续维护
- **文档**：每个模块写 README，解释 TDD 过程。
- **扩展**：可选添加字符串、I/O、更多内置。
- **评估**：项目末尾，用 gcov 确认覆盖率 >95%。如果卡住，参考书籍源代码调试。

这个计划确保渐进式开发，避免大跃进。起步时，从迭代 1 开始 Coding，坚持 TDD，能显著降低 bug。如果你需要某个迭代的伪代码或测试示例，随时说！加油，实现自己的 Lisp 会超级有成就感。